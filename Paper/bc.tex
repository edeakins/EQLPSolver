\documentclass[runningheads]{llncs}
%
\usepackage{xcolor}
\usepackage{graphicx}
%\usepackage{algorithm}
\usepackage[]{algorithm2e}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{easyeqn}
\usepackage{etex}
%\newtheorem{definition}{Definition}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
% \renewcommand\UrlFont{\color{blue}\rmfamily}

\newcommand{\cL}{{\mathcal L}}
\newcommand{\cF}{{\mathcal F}}
\newcommand{\cG}{{\mathcal G}}
\newcommand{\cO}{{\mathcal O}}
\newcommand{\cP}{{\mathcal P}}
\newcommand{\defeq}{\stackrel{\rm def}{=}}
\newcommand{\exclude}[1]{}
\newcommand{\orbG}[1]{\operatorname{orb}(#1,{\Gamma})}
%\newcommand{\papercomment}[1]{\medskip {\textcolor{blue} \bf Comment: #1} \medskip}
\newcommand{\orb}{\operatorname{orb}}
\newcommand{\stab}{\operatorname{stab}}%%
\newcommand{\Rosso}{\textcolor{red}}
\newcommand{\Blu}{\textcolor{blue}}
\newcommand{\comment}[1]{\textcolor{blue}{#1}}
\renewcommand{\vec}[1]{\mathbf{#1}}
\newtheorem{thm}{Theorem}[section]
\newtheorem{defn}{Definition}
\numberwithin{defn}{section} % important bit



\begin{document}
%
\title{Orbital Crossover\thanks{Supported by organization x.}}
%
%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{Ethan Deakins \inst{1} \and
James Ostrowski \inst{2} \and
Ben Kneuven \inst{3}
}
%
\authorrunning{F. Author et al.}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{University of Tennessee, USA \\
\email{edeakins@utk.edu}\\
\and
University of Knoxville Tennessee, USA \\
\email{jostrows@utk.edu}\\
\and
Sandia National Laboratories, USA\\
\email{bknueve@sandia.gov }
}
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}

\keywords{Linear Programming  \and Symmetry \and Equitable Partitions}
\end{abstract}
%
%
\section{Introduction}

Linear Programming (LP) has been long studied and is quite well understood.  There are many different algorithms that solve instances of LP exactly, some of which are: the simplex algorithm (active set method) and the barrier algorithm (interior point method).  In practice, LP instances typically solve very quickly using either method of subsets of the methods above (i.e., dual simplex).  However, LP is used in all open-source and commercial Integer Programming (IP) solvers to create bounds and cuts for the IP instance.  Thus, it is useful to study how to solve LP relaxations as quickly and efficiently as possible.

Now, LP instances may have what is known as symmetry in their feasible region.  By symmetry, we mean given $\vec{x}^1, \vec{x}^2 \in \cF$, two solutions to the LP instance, we have the following

\begin{equation}
\label{sym}
\vec{c}^T\vec{x}_1 = \vec{c}^T\vec{x}_2
\end{equation}

\noindent
where $\vec{c}^T, \ \cF$ are the vector of objective coefficients and feasible region of the instance, respectively.  We can use these symmetric solutions to our advantage to exploit the structure of the instances.

We may use symmetry groups and the mathematically weaker concept of equitable partitions(e.g., the method shown in  \cite{grohe2014dimension}) to aggregate these problems and solve a dimension reduced version of the instance.    These reduced problems are solvable in less time than the original model and retain the same objective value.  Formally, given an LP instance LP$^0$ formulated as 

\begin{align}
\label{stdLP}  \min \ &\vec{c}^T\vec{x}  \nonumber \\
\mbox{s.t. } & A\vec{x} = \vec{b}\\
& \vec{x} \geq 0. \nonumber
\end{align}

we may solve its aggregated formulation, say LP$^1$,

\begin{align}
\label{stdLPagg}  \min \ &\bar{\vec{c}}^T\bar{\vec{x}}  \nonumber \\
\mbox{s.t. } & \bar{A}\bar{\vec{x}} = \bar{\vec{b}}\\
& \bar{\vec{x}} \geq 0. \nonumber
\end{align}

and given $\vec{x}^*, \bar{\vec{x}}^*$, optimal solutions to LP$^0$ and LP$^1$, respectively, we have the property in \eqref{sym}.  Note that standard form will be considered in this paper for matter of convenience, but is not required. 

While the previous information shows that we can solve dimension reduced versions of LP instances and retain the optimal objective value, it does not hold that a vertex in LP$^1$ is a vertex in LP$^0$.  Actually, it is likely that the aggregated solution will be an interior point solution to LP$^0$.  Vertex solutions are preferable to interior point solutions due to their sparsity which is useful in both applications of LP and when LP is used for solving Integer Programming instances (a standard for modern IP solvers).  As such, we must now choose a method to obtain a vertex in the original model.  

One such method that offers a bridge over this impasse is that of the barrier algorithm which computes an interior point solution and then pushes it to a vertex solution (crossover).  However, according to \cite{gurobi2014crossover}, crossover is the most computationally expensive component of the barrier algorithm, consuming on average 29\% of the time of the barrier algorithm of models whose runtime was at least one second.  The next two closest in terms of computational expense were that of factorization (25\%) and presolve (14\%), with all other components having an expense that accounted for less than 10\% of the barrier algorithm's runtime.

The following paper proposes a more efficient method of moving from an interior point solution that is obtained from aggregating the LP instances using the method in \cite{grohe2014dimension}.  This is interesting in general for LP because an LP may have a non-trivial (i.e., a non-discrete) coarsest equitable partition without having any symmetry.  In our method we \textit{crush} (aggregate) a given model based off its initial equitable partition, solve the crushed model and then \textit{un-crush} (disaggregate) the model by iteratively refining the coarsest equitable partition of the original instance based on an isolation step that will be covered later.  While un-crushing the instance, we make use of the well-known simplex algorithm with some minor edits in the method in which we choose entering variables, as well as, maintaining our active set.

\comment{I am going to add a contributions paragraph here, but I am not totally sure what to say our contributions are other than an efficient interior point algorithm.} 


\section{Equitable partitions and color refinement}
\subsection{Equitable partitions}
From this point forward, by graph we mean a finite, undirected weighted graph.  An equitable partition of a graph $G = (V, E)$ can be defined as follows.  Let $\Pi$ denote a partition of the vertices of a graph then we have

\begin{defn}
	A partition $\Pi$ of the vertices of a graph $G = (V, E)$ is considered equitable if $\ \forall \ \pi_i, \pi_j \in \Pi$
	
	\begin{equation}
	\label{eqpart}
		\sum_{u \in \pi_i} w_{uv} = b_{ij}, \ \forall \ v \in \pi_j
	\end{equation}
	
\end{defn}

\noindent
Note that a \textit{coarsest} equitable partition is an equitable partition that cannot be further refined.  where $w_{uv}, b_{ij}$ are the weights along the edge $(u,v)$ and a constant specific to parts $\pi_i, \pi_j$, respectively.  For those who have used equitable partitioning for unweighted graphs, note that this definition differs slightly in that we are summing the edge weights between nodes of two parts rather than the degree sums of nodes in two distinct parts.  

An equitable partition of a graph is similar to a collection of orbits as the result of a symmetry group.  The difference lies in the restriction on permutation matrices.  A symmetry group may be thought of as a collection of permutation matrices on a group (vertices in this case) such that each row and column sum to 1 and the entries are binary.  An equitable partition can be thought of as permutation matrices but with the notion that the binary constraint has been relaxed to a continuous value between 0 and 1.

\subsection{Color refinement}
\cite{grohe2014dimension} gives a method of computing equitable partitions for an LP instance via a color refinement scheme.  First, note that any LP can be represented as a bipartite graph $G = (V, E), \ V = V_1 \cup V_2, \ V_1 \cap V_2 = \emptyset$.  Here $V_1, V_2$ are two disjoint collections of the nodes of the bipartite graph, namely the variables and constraints respectively.  Now we can use color refinement to compute an equitable partition of the vertices.  First each variable node $u \in V_1$ receives a color that maps it to its objective coefficient.  Then, these sames nodes are examined again and the color of the nodes is updated based upon upper and lower bounds of the variables.  For example, if two variables have the same objective coefficient but differ in either of their bounds, then these two variables will need to be assigned different colors.  Constraint nodes $v \in V_2$ are handled in a similar fashion, however these nodes only need be examined once initially and are assigned on a color that maps it to the right hand side of that constraint.

Now, with each node colored, we have a trivial partition of the bipartite graph representing this LP, however this partition may not be equitable.  If not, we may achieve an equitable partition by choosing a part $\pi_i \in \Pi$ and use it to refine all other parts $\pi_j \in \Pi$.  This refined procedures evaluates the condition in \eqref{eqpart} for all pairs $\pi_i, \pi_j \in \Pi$ where $i$ is fixed.  If a node in a part $\pi_j, j \neq i$ violates this condition, it is assigned a new color.  Any other node that violates this condition is either assigned to the new color given to the first node that was recolored, or it is given a new color as well.  This process continues until no new colors are given in the partition.  For details see \cite{grohe2014dimension}.
%
% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.
%
 \bibliographystyle{splncs04}
 \bibliography{bc.bib}
 
 \end{document}
%
%\section{Conclusions: can we extend the method to other problems?}
%
%\section{Questions}
%\label{sec:questions}
%\begin{itemize}
%\item The stable set problem on bipartite graphs is a bipartite matching problem: however we have even cycles, so PSBs seem not useful
%\item More in general, consider a line graph $G$. By definition, the neighborhood of any vertex can be partitioned into two cliques. Does it imply something to disjunction \ref{eq:pseudo-ss}?
%\end{itemize}
%
%
%
%\end{document}
%
%\section{Impact on Formulation}
%
%\comment {I have many doubts about this section as our focus is on removing multiple equivalent solutions, not on strengthening the relaxation. Of course, showing some polyhedral result would be nice,
%	but it doesn't seem straightforward. Some of the comments below could be probably moved in the computational section, when we discuss the effect of preprocessing.}\\
%
%\noindent
%The constraints generated by a stable set $S$ can have an interesting impact on
%the stable set's underlying polytope. Trivially, the constraints
%in~\eqref{eq:constraints} will fix $x_i$ to one for all $v_i$s in $S$ with
%degrees zero or one. Similarly, if $v_i\in S$ has degree two, with neighbors
%$v_j$ and $v_k$, then~\eqref{eq:constraints} implies that $x_j = x_k$. In
%general, though, we would expect preprocessing to have made these substitutions.
%
%Unfortunately, the adding~\eqref{eq:constraints} are unlikley to change the
%solution the the LP relaxation for the basic formulation given in
%~\eqref{eq:ss}. This can easily be seen by considering that, for graphs with a
%minimum degree of two, the solution $x_i = \frac{1}{2}$ for all $i$ is both
%feasible and optimal to the relaxation with and without the constraints in
%~\eqref{eq:constraints}. However, many times these constraints can be used in
%conjunction with clique inequalites or other cuts to improve the quality (and
%dimension) of the LP relaxation.
%
%{\em Example}
%
%%%\begin{figure}
%%	\caption{Example Graph}
%%	\label{fig:graph}
%%	\centering
%%	\includegraphics[width=0.5\textwidth]{star}
%%\end{figure}
%
%Consider the graph shown in Figure~\ref{fig:graph}. It is easy to verify that a
%facet for the independent set problem is $2x_1 + x_2+ x_3+ x_4+ x_5+ x_6 \leq
%2$. Consider, now, the stable set $S^1 = \{v_1\}$. The constraint generated by
%$S^1$ is $2x_1 + x_2+ x_3+ x_4+ x_5+ x_6 \geq
%2$. Thus, adding this constraint implies that it must hold with equality,
%reducing the dimension of the problem.
%
%Of course, there are many other stable sets that can be chosen. Consider the set
%of constraints generated by $S^2 = \{v_2,\ v_4\}$. Such constraints, combined
%with clique inequalities, can be used to reduce the problem to zero dimensions
%(as they imply that $x_2$ and $x_4$ have to be one).
%
%The impact of the set of constraints generated by $S$ on the underlying
%polyhedron is highly dependent on the selection of $S$. However, if chosen well,
%they can be used in conjunction with preprocessing techniques and cut generation
%techniques to improve the LP relaxation. This is demonstrated in
%computational experience.
%
%
%\subsection{Represenative Solutions and Solution Set Recovery}
%\comment{this section has to be improved} \\
%
%Stable sets that satisfy constraints~\eqref{eq:constraints} for
%a given set $S$ can be viewed as representative solutions. Through them, the entire set of solutions can be recovered. Let
%$\{x^i\}_i$ be the set of all optimal solutions (with cardinality $z^*$)
%satisfying~\eqref{eq:constraints}. Let $P^i$ be the set defined by the
%following constraints:
%
%
%
%\begin{eqnarray*}
%	\sum_{l\in V} x_l = z^* &\\
%	x_k + x_l \leq 1 & (k, l) \in E\\
%	x_k + \sum_{l \in N(k)} x_l \leq 1 & k \in S \mbox { with } x_k^i = 1\\
%	\sum_{l \in N(k)} x_l \geq 2 & k \in S \mbox { with } x_k^i = 0\\
%	x_i \in \{0,1\}. &
%\end{eqnarray*}
%
%\noindent
%Any optimal solution, even one not satisfying~\eqref{eq:constraints}, will be
%feasible for at least one set $P^i$. Note that there may be two different
%solutions, $i$ and $j$,  that satisfy~\eqref{eq:constraints} whose resulting
%$P^i$ and $P^j$ are identical. This can be seen by considering the solutions to
%the graph in Figure~\ref{fig:graph} generated by the seed independent set $S =
%\{1\}$.

